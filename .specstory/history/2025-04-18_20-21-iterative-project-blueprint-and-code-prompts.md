<!-- Generated by SpecStory -->

# Iterative Project Blueprint and Code Prompts (2025-04-18 13:21:41)

_**User**_

Draft a detailed, step-by-step blueprint for building this project. Then, once you have a solid plan, break it down into small, iterative chunks that build on each other. Look at these chunks and then go another round to break it into small steps. Review the results and make sure that the steps are small enough to be implemented safely with strong testing, but big enough to move the project forward. Iterate until you feel that the steps are right sized for this project.

From here you should have the foundation to provide a series of prompts for a code-generation LLM that will implement each step in a test-driven manner. Prioritize best practices, incremental progress, and early testing, ensuring no big jumps in complexity at any stage. Make sure that each prompt builds on the previous prompts, and ends with wiring things together. There should be no hanging or orphaned code that isn't integrated into a previous step.

Make sure and separate each prompt section. Use markdown. Each prompt should be tagged as text using code tags. The goal is to output prompts, but context, etc is important as well.

@specs 

---

_**Assistant**_



---

Okay, Big D. Let's get this project planned out.

First, I need to understand the requirements. I'll read the specification file you attached.



---

Read file: docs/specs/01-initial.md

---

Okay, Big D, I've reviewed the specifications for the "Stream Speaker Scheduling Bot". It aims to automate scheduling speakers via Discord, using natural language, interacting through threads, and storing data in MongoDB.

Here's the high-level plan:

1.  **Project Setup:** Initialize the Node.js project, install necessary dependencies (`discord.js`, MongoDB driver, NLP library, testing framework).
2.  **Core Bot Framework:** Set up the basic Discord bot connection, authentication, and message listening capabilities. Reuse existing `llm.js` structure if possible.
3.  **Database Model:** Define the MongoDB schema and model for `scheduledSpeakers`, including the unique index on `scheduledDate`.
4.  **Date Calculation Logic:** Implement the function to find the next N available Fridays, excluding booked dates from the database.
5.  **Sign-up Intent Recognition:** Implement logic (NLP or keyword/regex) to detect when a user wants to sign up.
6.  **Scheduling Conversation Flow:**
    *   Handle thread creation upon sign-up intent.
    *   Manage the conversation: ask for topic, present dates, parse date selection, handle clarification, confirm booking.
7.  **Database Interaction:** Implement functions to query for booked dates and save confirmed bookings.
8.  **Schedule Viewing Intent Recognition:** Implement logic to detect when a user wants to view the schedule.
9.  **Schedule Display Logic:** Implement the function to fetch upcoming speakers from the database and format the output message.
10. **Error Handling:** Implement robust error handling for NLP ambiguity, database issues, scheduling conflicts (race conditions), and Discord API errors.
11. **Testing:** Implement unit, integration, and (manual) E2E tests covering all core logic and flows.

Now, let's break this down into smaller, iterative steps suitable for LLM prompts, focusing on TDD:

**Phase 1: Foundation & Date Logic**

*   **Step 1.1: Project Setup & Basic Bot:**
    *   **Task:** Initialize a new Node.js project, install `discord.js`, `mongodb`, `ava` (for testing), and `mongodb-memory-server` (for test DB). Set up basic bot login and a simple ping/pong command for testing connection. Configure `standard.js` linting.
    *   **Testing:** Test the ping/pong command works. Ensure `npm test` runs and exits cleanly. Ensure linter passes (`standard --fix` if needed).
*   **Step 1.2: Database Model & Connection:**
    *   **Task:** Define the Mongoose schema for `scheduledSpeakers` (using `discordUserId`, `discordUsername`, `topic`, `scheduledDate`, `bookingTimestamp`, `threadId`) in a `models/scheduledSpeaker.js` file. Add the unique index on `scheduledDate`. Create a utility module (`lib/db.js`) to handle MongoDB connection (using environment variables for connection string) and disconnection (crucial for clean test exit).
    *   **Testing:** Write unit tests (`ava`) using `mongodb-memory-server` to verify the model schema, ensure the unique index prevents duplicate dates, and test the connection/disconnection utility.
*   **Step 1.3: Available Date Calculation Logic:**
    *   **Task:** Create a standalone function (e.g., in `lib/scheduleLogic.js`) `findNextAvailableFridays({ count: 3, startDate: new Date(), bookedDates: [] })`. This function should take a start date, the number of Fridays to find, and an array of already booked ISODate strings (YYYY-MM-DD format). It should return an array of the next `count` Friday `Date` objects that are *not* in the `bookedDates` array.
    *   **Testing:** Write unit tests (`ava`) for `findNextAvailableFridays` with various scenarios: no booked dates, some booked dates, consecutive booked dates, start date is a Friday, etc. Ensure it correctly handles timezones/date boundaries by focusing only on the date part (YYYY-MM-DD).

**Phase 2: Sign-up Flow (Core Logic)**

*   **Step 2.1: Sign-up Intent Recognition (Simple):**
    *   **Task:** Modify the bot's message handler. Listen for messages mentioning the bot (`@BotName`). Use simple keyword matching (e.g., "sign up", "speak", "present") within the message content to detect a sign-up request. For now, just log detection to the console.
    *   **Testing:** Write integration tests (mocking `discord.js` client) to send various messages and verify that only sign-up-related messages trigger the console log.
*   **Step 2.2: Thread Creation:**
    *   **Task:** Upon detecting sign-up intent, use `message.startThread()` to create a private thread named "Speaker Signup - [Username]". Respond *inside the thread* with "Welcome! What topic would you like to present?". Store the `threadId` temporarily (in memory for now, will link to DB later).
    *   **Testing:** Update integration tests to verify thread creation and the bot's initial response *within* the thread. Mock `startThread`.
*   **Step 2.3: Topic Collection & Date Fetching:**
    *   **Task:** Listen for replies *within active sign-up threads*. Assume the first reply is the topic. Store it (in memory). Fetch booked dates from the `scheduledSpeakers` collection (using the DB connection utility and model from Phase 1).
    *   **Testing:** Write integration tests simulating a user reply in the thread. Verify the topic is stored (mock storage). Mock the database call and verify it's called correctly.
*   **Step 2.4: Date Presentation:**
    *   **Task:** Using the booked dates from Step 2.3, call `findNextAvailableFridays` (from Step 1.3) to get the next 3 available Fridays. Format these dates clearly (e.g., "Friday, October 27th") and present them as options in a reply within the thread. Handle the case where fewer than 3 dates are found (as per spec).
    *   **Testing:** Write integration tests verifying the bot calls `findNextAvailableFridays` with mocked booked dates, formats the returned dates correctly, and sends the options message in the thread. Test the "no dates available" scenario.

**Phase 3: Sign-up Flow (Confirmation & Persistence)**

*   **Step 3.1: Date Selection Parsing (Simple):**
    *   **Task:** Listen for the user's reply after dates are presented. Implement simple parsing logic (e.g., checking for "first", "second", "third", or matching the formatted date string) to understand which proposed date was selected. For now, don't handle ambiguity or requests for other dates; assume a clear selection of a *proposed* date. Log the selected date.
    *   **Testing:** Write unit tests for the parsing logic with various valid inputs corresponding to the presented options. Write integration tests simulating user replies selecting each option and verify the correct date is logged.
*   **Step 3.2: Booking Confirmation & Persistence:**
    *   **Task:** Once a date is selected (from Step 3.1), send a confirmation message in the thread: "Great! You're confirmed to speak on [Topic] on [Confirmed Date]." Then, save the booking (using `discordUserId`, `discordUsername` from the original message author, the collected `topic`, the selected `scheduledDate`, a new `bookingTimestamp`, and the `threadId`) to the `scheduledSpeakers` collection in MongoDB.
    *   **Testing:** Write integration tests. Simulate the full sign-up flow up to date selection. Verify the confirmation message is sent. Verify that a document with the correct data is inserted into the test database (`mongodb-memory-server`). Test the race condition: attempt to book the same date twice and verify the second attempt fails due to the unique index (mock the DB error appropriately for the test).

**Phase 4: Schedule Viewing & Refinement**

*   **Step 4.1: Schedule View Intent Recognition (Simple):**
    *   **Task:** Similar to Step 2.1, add logic to the main message handler to detect messages mentioning the bot and asking for the schedule (e.g., keywords "schedule", "upcoming", "speakers"). Log detection to console.
    *   **Testing:** Write integration tests (mocking `discord.js` client) simulating various schedule request messages and verify the console log triggers appropriately.
*   **Step 4.2: Fetch & Display Schedule:**
    *   **Task:** Upon detecting a schedule view request, query the `scheduledSpeakers` collection for all documents with `scheduledDate` >= today, sorted by `scheduledDate`, limit 5. Format the results into a user-friendly message ("Upcoming Speakers:\n- [Date1]: @[Username1]\n...") and send it as a reply in the original channel. Handle the case where no speakers are scheduled.
    *   **Testing:** Write integration tests. Seed the test database with a few upcoming and past speaker records. Simulate a schedule request message. Verify the correct database query is made. Verify the formatted output message matches the expected schedule based on the seeded data. Test the "no upcoming speakers" message.
*   **Step 4.3: NLP & Clarification Refinement (Sign-up):**
    *   **Task:** Enhance Step 3.1 (Date Selection Parsing). Introduce a basic NLP library (e.g., `compromise`) or more robust regex/keyword logic to better handle natural language date selection (e.g., "how about the first one", "the 15th is good"). If the selection is ambiguous or doesn't match a proposed date, implement the clarification loop: reply asking the user to explicitly choose from the initially proposed dates.
    *   **Testing:** Update/add unit tests for the enhanced parsing logic, covering ambiguous inputs and inputs that *don't* match the proposals. Update integration tests to simulate ambiguous replies and verify the bot sends the clarification message instead of confirming. Test that a subsequent clear reply breaks the loop and leads to confirmation.
*   **Step 4.4: Error Handling Implementation:**
    *   **Task:** Implement the error handling strategies outlined in the spec: catch potential DB errors during reads/writes (log internally, reply with generic message), handle the unique index violation during save (inform user date became unavailable, maybe re-trigger date proposal - simpler first: just fail), handle NLP ambiguity (already partially done in 4.3, add final "ask admin" message if loop fails), handle Discord API errors gracefully (log, maybe generic user message).
    *   **Testing:** Write specific integration tests to trigger each error condition (e.g., force DB connection error via mocking, attempt duplicate date booking, provide repeatedly ambiguous input) and verify the bot responds according to the spec and logs errors appropriately.

This breakdown provides small, testable steps that build upon each other. Now, I'll format the LLM prompts for each step into the `docs/plans/01-initial.md` file.

Okay, Big D, I will now write the plan and the detailed LLM prompts into `docs/plans/01-initial.md`.

---

```diff
- 
+ # Stream Speaker Scheduling Bot - Build Plan & LLM Prompts
+ 
+ ## High-Level Plan
+ 
+ 1.  **Project Setup:** Initialize Node.js, install dependencies (`discord.js`, `mongodb`, `ava`, `mongodb-memory-server`, `standard`), configure linter.
+ 2.  **Core Bot Framework:** Basic Discord connection, ping/pong.
+ 3.  **Database Model:** Define `scheduledSpeakers` schema/model (`models/scheduledSpeaker.js`), unique index, connection utility (`lib/db.js`).
+ 4.  **Date Calculation Logic:** Implement `findNextAvailableFridays` (`lib/scheduleLogic.js`).
+ 5.  **Sign-up Intent Recognition:** Simple keyword matching for sign-up requests.
+ 6.  **Scheduling Conversation Flow (Part 1):** Thread creation, topic collection, date fetching.
+ 7.  **Scheduling Conversation Flow (Part 2):** Date presentation.
+ 8.  **Scheduling Conversation Flow (Part 3):** Simple date selection parsing, booking confirmation, persistence to DB.
+ 9.  **Schedule Viewing Intent Recognition:** Simple keyword matching for schedule view requests.
+ 10. **Schedule Display Logic:** Fetch upcoming speakers, format, and display.
+ 11. **Refinement:** Enhance date selection parsing with NLP/better logic and add clarification loop.
+ 12. **Error Handling:** Implement robust error handling for DB, NLP, race conditions, API errors.
+ 13. **Testing:** Ensure comprehensive unit, integration tests (`ava`, `mongodb-memory-server`, mocked `discord.js`).
+ 
+ ---
+ 
+ ## LLM Prompts for Implementation (TDD Approach)
+ 
+ **Important Context for ALL Prompts:**
+ 
+ *   **Language:** Node.js
+ *   **Style:** `standard.js` (Use `npx standard --fix` if needed)
+ *   **Testing:** Use `ava`. Mock external services (`discord.js`, use `mongodb-memory-server` for DB). Ensure tests exit cleanly (`npm test`). No `tape.plan()`.
+ *   **JS Conventions:** No classes. Top of file: package requires, local requires, constants, immediate code, `module.exports`, functions. Use options object for >2 function args. No ternaries in complex logic.
+ *   **Database:** Access MongoDB via Mongoose models only (`models/*.js`). Use `lib/db.js` for connection management. Schema defined in spec.
+ *   **Environment:** Assume `DISCORD_BOT_TOKEN` and `MONGODB_URI` are available as environment variables.
+ 
+ ---
+ 
+ ### Prompt 1.1: Project Setup & Basic Bot
+ 
+ ```text
+ Task: Set up the initial Node.js project structure for the Stream Speaker Scheduling Bot.
+ 
+ 1.  Initialize a new Node.js project (`npm init -y`).
+ 2.  Install necessary dependencies: `npm install discord.js mongodb mongoose dotenv`
+ 3.  Install development dependencies: `npm install --save-dev ava standard mongodb-memory-server`
+ 4.  Create a basic bot entry point file (`bot.js`).
+ 5.  Implement basic Discord bot login using `discord.js` and the `DISCORD_BOT_TOKEN` environment variable (use `dotenv` to load a `.env` file for local development).
+ 6.  Add a simple message listener that replies "pong" when it receives "!ping".
+ 7.  Create a `.env.example` file with `DISCORD_BOT_TOKEN=` and `MONGODB_URI=`.
+ 8.  Add a `.gitignore` file ignoring `node_modules/`, `.env`, `coverage/`, etc.
+ 9.  Configure `package.json`:
+     *   Add a `start` script: `node bot.js`
+     *   Add a `test` script: `ava`
+     *   Add a `lint` script: `standard`
+     *   Add a `lint:fix` script: `standard --fix`
+ 10. Write a simple test file (`test/bot.test.js`) using `ava` that ensures the test runner works (e.g., `test('basic assertion', t => t.pass());`).
+ 11. Ensure `npm test` runs and exits cleanly.
+ 12. Ensure `npm run lint` passes (run `npm run lint:fix` if necessary).
+ 
+ Provide the necessary file contents (`bot.js`, `package.json`, `.gitignore`, `.env.example`, `test/bot.test.js`). Do not include actual token/URI values.
+ ```
+ 
+ ---
+ 
+ ### Prompt 1.2: Database Model & Connection
+ 
+ ```text
+ Task: Define the MongoDB model and connection utility.
+ 
+ Building on the previous step:
+ 
+ 1.  Create `lib/db.js`:
+     *   Export an async function `connectDB` that connects to MongoDB using Mongoose and the `MONGODB_URI` env var. Handle connection errors.
+     *   Export an async function `disconnectDB` that disconnects Mongoose.
+     *   Ensure the connection is established only once (singleton pattern or check Mongoose connection state).
+ 2.  Create `models/scheduledSpeaker.js`:
+     *   Require Mongoose.
+     *   Define a Mongoose schema according to the spec:
+         *   `discordUserId`: String, required
+         *   `discordUsername`: String, required
+         *   `topic`: String, required
+         *   `scheduledDate`: Date, required
+         *   `bookingTimestamp`: Date, default: Date.now
+         *   `threadId`: String
+     *   Add a unique index on `scheduledDate`. Use `schema.index({ scheduledDate: 1 }, { unique: true });`
+     *   Create and export the Mongoose model named `ScheduledSpeaker`.
+ 3.  Create `test/db.test.js`:
+     *   Use `ava` and `mongodb-memory-server`.
+     *   In test setup (`test.before`), start the memory server, get its URI, set it as `MONGODB_URI` env var, and call `connectDB`.
+     *   In test teardown (`test.after.always`), call `disconnectDB` and stop the memory server.
+     *   Write tests to:
+         *   Verify a `ScheduledSpeaker` document can be created and saved.
+         *   Verify saving a document with missing required fields fails.
+         *   Verify attempting to save two documents with the exact same `scheduledDate` fails due to the unique index constraint (catch the error). Ensure only the date part matters for uniqueness (e.g., save `new Date('2023-10-27T10:00:00Z')` and try saving `new Date('2023-10-27T15:30:00Z')` - this *should* fail if the type is just Date, but might need adjustment if storing precise time). *Correction based on spec: the unique index should likely only consider the date part. For simplicity with Mongoose `Date`, the index might catch identical timestamps. A pre-save hook or application-level check might be needed later if exact date-only uniqueness is strict.* For now, test duplicate exact `Date` objects.
+ 4.  Update `.gitignore` to include `.env`.
+ 5.  Modify `bot.js` to call `connectDB()` on startup after login. Add basic error handling if connection fails.
+ 
+ Provide the contents of `lib/db.js`, `models/scheduledSpeaker.js`, and `test/db.test.js`. Show modifications to `bot.js`.
+ ```
+ 
+ ---
+ 
+ ### Prompt 1.3: Available Date Calculation Logic
+ 
+ ```text
+ Task: Implement the logic to find available Friday slots.
+ 
+ Building on the previous steps:
+ 
+ 1.  Create `lib/scheduleLogic.js`.
+ 2.  Implement an exported function `findNextAvailableFridays({ count = 3, startDate = new Date(), bookedDates = [] })`:
+     *   `count`: Number of available Fridays to find.
+     *   `startDate`: The date to start searching from.
+     *   `bookedDates`: An array of **Date objects** representing booked dates (we'll query the DB later, but the function takes Date objects).
+     *   The function should iterate through dates starting from `startDate`.
+     *   For each date, check if it's a Friday (e.g., using `getDay()`, where Sunday=0, Friday=5).
+     *   If it's a Friday, check if its date part (YYYY-MM-DD) matches the date part of any date in the `bookedDates` array. **Important:** Compare only the year, month, and day, ignoring time. Convert dates to `YYYY-MM-DD` strings for reliable comparison.
+     *   If it's a Friday and its date part is *not* in `bookedDates`, add it to a results array.
+     *   Continue until `count` available Fridays are found or a reasonable future limit is reached (e.g., 6 months) to prevent infinite loops if slots are scarce.
+     *   Return the array of found `Date` objects.
+ 3.  Create `test/scheduleLogic.test.js`:
+     *   Use `ava`.
+     *   Write unit tests for `findNextAvailableFridays`:
+         *   Test case: No booked dates, starting mid-week. Should return the next 3 Fridays.
+         *   Test case: First upcoming Friday is booked. Should return the following 3 Fridays.
+         *   Test case: Multiple consecutive Fridays booked.
+         *   Test case: `startDate` itself is an available Friday.
+         *   Test case: `startDate` itself is a booked Friday.
+         *   Test case: `bookedDates` contains dates with different times but the same date part.
+         *   Test case: Ensure it finds dates across month/year boundaries.
+         *   Test case: Scenario where fewer than `count` dates are found within the search limit (e.g., book all Fridays for 7 months).
+ 
+ Provide the contents of `lib/scheduleLogic.js` and `test/scheduleLogic.test.js`.
+ ```
+ 
+ ---
+ 
+ ### Prompt 2.1: Sign-up Intent Recognition (Simple)
+ 
+ ```text
+ Task: Detect basic user intent to sign up for speaking.
+ 
+ Building on the previous steps:
+ 
+ 1.  Modify the message listener in `bot.js`.
+ 2.  Check if the message mentions the bot (`message.mentions.has(client.user.id)`).
+ 3.  If mentioned, perform a simple case-insensitive check on `message.content` for keywords like "sign up", "speak", "present", "talk on stream".
+ 4.  If a keyword is found, log "Sign-up intent detected from [username]" to the console. *Do not proceed further yet.*
+ 5.  Refactor the message handling logic into a separate async function `handleMessage(message)` for clarity. The main `'messageCreate'` event listener should just call this function.
+ 6.  Create `test/intent.test.js` (or add to `bot.test.js` if preferred, but keep separate for focus):
+     *   Use `ava`.
+     *   Mock the necessary `discord.js` `message` object structure (including `mentions.has`, `content`, `author.username`).
+     *   Call the exported `handleMessage` function (you'll need to export it from `bot.js`).
+     *   Test various message contents:
+         *   Messages mentioning the bot with keywords -> verify console log (mock `console.log`).
+         *   Messages mentioning the bot without keywords -> verify no log.
+         *   Messages not mentioning the bot -> verify no log.
+         *   Messages with keywords but different casing.
+ 
+ Provide the updated `bot.js` and the new `test/intent.test.js` (or updated `bot.test.js`).
+ ```
+ 
+ ---
+ 
+ ### Prompt 2.2: Thread Creation
+ 
+ ```text
+ Task: Create a private thread when sign-up intent is detected.
+ 
+ Building on the previous steps:
+ 
+ 1.  Modify the `handleMessage` function in `bot.js`.
+ 2.  When sign-up intent is detected (from Prompt 2.1):
+     *   Check if the message is in a guild channel (threads can't be started from DMs easily without extra permissions/checks). If not, maybe log a warning and ignore.
+     *   Use `message.startThread()` to create a thread.
+         *   `name`: `Speaker Signup - ${message.author.username}`
+         *   `autoArchiveDuration`: Choose a suitable duration (e.g., 60 minutes or 1440 for a day). Consider making it configurable.
+         *   `reason`: 'Automated speaker sign-up process'
+     *   Handle potential errors during thread creation (e.g., missing permissions). Log errors.
+     *   If thread creation is successful, send a reply *inside the newly created thread*: `thread.send("Welcome! What topic would you like to present?");`
+     *   For now, we need a way to track which threads are active sign-up flows. Use a simple in-memory `Map` or `Set` in `bot.js` to store the `threadId` of newly created sign-up threads. Add the `thread.id` to this map/set upon successful creation. (This is temporary state).
+ 3.  Update `test/intent.test.js` (or relevant test file):
+     *   Mock `message.startThread` to return a mock `thread` object. The mock `thread` object needs a mock `send` method and an `id`.
+     *   Mock `message.inGuild` property (or equivalent check).
+     *   Verify `message.startThread` is called with the correct options when intent is detected in a guild message.
+     *   Verify `thread.send` is called with the correct welcome message.
+     *   Verify the `thread.id` is added to the in-memory tracking set/map (mock the set/map).
+     *   Test the case where the message is not in a guild.
+     *   Test error handling during `startThread` (mock it to throw an error).
+ 
+ Provide the updated `bot.js` and the updated test file.
+ ```
+ 
+ ---
+ 
+ ### Prompt 2.3: Topic Collection & Date Fetching
+ 
+ ```text
+ Task: Collect the topic reply within the thread and fetch booked dates.
+ 
+ Building on the previous steps:
+ 
+ 1.  Modify the `handleMessage` function in `bot.js`.
+ 2.  Add a check: If the message's `channel` is a thread (`message.channel.isThread()`) AND its `channelId` is present in our active sign-up thread tracking map/set (from Prompt 2.2):
+     *   Assume this message is part of a sign-up flow.
+     *   We need to know *what step* we are in. Modify the in-memory tracking `Map` from Prompt 2.2. Instead of just storing `threadId`, store `Map<threadId, { state: 'awaiting_topic', originalMessageAuthor: message.author }>`. When creating the thread, store `{ state: 'awaiting_topic', originalMessageAuthor: message.author }`.
+     *   If the message is in an active thread and the state is `'awaiting_topic'`:
+         *   Assume the `message.content` is the topic.
+         *   Store the topic temporarily, associated with the `threadId` in the map: `threadState.topic = message.content;`.
+         *   Update the state: `threadState.state = 'awaiting_date_selection';`
+         *   Query the database: Use the `ScheduledSpeaker` model (from Prompt 1.2) to `find` all scheduled speakers (`scheduledDate: { $gte: new Date() }` might be useful, though `findNextAvailableFridays` handles filtering). Get the `scheduledDate` field from the results. Convert these dates to **Date objects**.
+         *   Log the fetched booked dates (or that none were found) for now. The next step will present them.
+         *   Handle potential database errors during the fetch. Log errors. Inform the user in the thread if DB fetch fails ("Sorry, I couldn't check the schedule right now.").
+ 3.  Update tests:
+     *   Mock the `ScheduledSpeaker.find` method using a library like `sinon` or manual mocking if simple.
+     *   Simulate a message arriving in a tracked thread ID.
+     *   Verify the state in the mock map is updated correctly (`awaiting_topic` -> `awaiting_date_selection`).
+     *   Verify the topic is stored in the mock map.
+     *   Verify `ScheduledSpeaker.find` is called.
+     *   Test the scenario where the database query returns booked dates.
+     *   Test the scenario where the database query returns an empty array.
+     *   Test the scenario where the database query throws an error, verifying the error message is sent to the thread (mock `message.channel.send`).
+ 
+ Provide the updated `bot.js` and the updated test file. Remember to require the `ScheduledSpeaker` model.
+ ```
+ 
+ ---
+ 
+ ### Prompt 2.4: Date Presentation
+ 
+ ```text
+ Task: Present available dates to the user in the thread.
+ 
+ Building on the previous steps:
+ 
+ 1.  Modify `bot.js` within the logic handling replies in active sign-up threads (specifically after fetching the topic and booked dates from Prompt 2.3).
+ 2.  Require `findNextAvailableFridays` from `lib/scheduleLogic.js`.
+ 3.  Call `findNextAvailableFridays` using the booked `Date` objects fetched from the database in the previous step.
+ 4.  Format the returned available `Date` objects into a user-friendly string array (e.g., "Friday, October 27th, 2023"). Helper function recommended.
+ 5.  Construct the message to send to the thread:
+     *   If dates were found: "Okay, your topic is '[topic]'. The next available dates are:
+ 1. [Formatted Date 1]
+ 2. [Formatted Date 2]
+ 3. [Formatted Date 3]
+ Which date works for you?" (Adjust numbering/message if fewer than 3 found).
+     *   If `findNextAvailableFridays` returns an empty array: "Okay, your topic is '[topic]'. Unfortunately, there are no upcoming Friday slots available in the near future. Please check back later or contact an admin." Update the state in the map to `'closed'` or remove the threadId.
+ 6.  Send the constructed message to the thread (`message.channel.send(...)`).
+ 7.  Update tests:
+     *   Mock `findNextAvailableFridays`.
+     *   Simulate the flow up to topic submission.
+     *   Test the case where `findNextAvailableFridays` returns 3 dates: Verify it's called correctly (with dates from mock DB), verify the formatting of dates, verify the correct message with options is sent to the thread (mock `message.channel.send`).
+     *   Test the case where `findNextAvailableFridays` returns 1 date.
+     *   Test the case where `findNextAvailableFridays` returns 0 dates: Verify the "no slots" message is sent and the state is updated/thread removed from the map.
+ 
+ Provide the updated `bot.js` and the updated test file. Remember to require `findNextAvailableFridays`.
+ ```
+ 
+ ---
+ 
+ ### Prompt 3.1: Date Selection Parsing (Simple)
+ 
+ ```text
+ Task: Parse the user's reply to select one of the presented dates.
+ 
+ Building on the previous steps:
+ 
+ 1.  Modify `bot.js` to handle the next state in the sign-up thread conversation.
+ 2.  Add logic: If a message is in an active thread and the state is `'awaiting_date_selection'`:
+     *   Retrieve the proposed dates that were presented to the user (you'll need to store these in the state map along with the state, e.g., `threadState.proposedDates = availableDates;`).
+     *   Implement **simple parsing** on `message.content`:
+         *   Check for case-insensitive "1st", "first", "1". If found, select `proposedDates[0]`.
+         *   Check for "2nd", "second", "2". If found, select `proposedDates[1]`.
+         *   Check for "3rd", "third", "3". If found, select `proposedDates[2]`.
+         *   Check if the message content exactly matches one of the formatted date strings presented earlier (store the formatted strings too, or reformat `proposedDates`).
+     *   If a valid selection is made based on the *proposed* dates:
+         *   Store the selected `Date` object: `threadState.selectedDate = chosenDate;`
+         *   Update the state: `threadState.state = 'awaiting_confirmation';`
+         *   Log the selected date for now: "User selected date: [selectedDate]".
+     *   If the input doesn't simply match 1st/2nd/3rd or the exact string, *do nothing yet* (the clarification loop will be added later).
+ 3.  Update tests:
+     *   Set up the mock state map to be in `'awaiting_date_selection'` with mock `proposedDates` (both Date objects and formatted strings).
+     *   Simulate user replies:
+         *   "first" -> Verify state updates to `'awaiting_confirmation'`, correct date stored in map, log occurs.
+         *   "2" -> Verify state updates, correct date stored, log occurs.
+         *   "The third one" -> Verify state *does not* change yet (simple parsing fails).
+         *   Message matching the formatted string for the 2nd proposed date -> Verify state updates, correct date stored, log occurs.
+         *   "None of those work" -> Verify state does not change.
+ 
+ Provide the updated `bot.js` and the updated test file.
+ ```
+ 
+ ---
+ 
+ ### Prompt 3.2: Booking Confirmation & Persistence
+ 
+ ```text
+ Task: Confirm the booking with the user and save it to the database.
+ 
+ Building on the previous steps:
+ 
+ 1.  Modify `bot.js` to handle the `'awaiting_confirmation'` state. This logic should run immediately after a valid date selection is parsed in Prompt 3.1.
+ 2.  Retrieve the necessary information from the state map: `topic`, `selectedDate`, `originalMessageAuthor`.
+ 3.  Create a new `ScheduledSpeaker` document instance with:
+     *   `discordUserId`: `originalMessageAuthor.id`
+     *   `discordUsername`: `originalMessageAuthor.username`
+     *   `topic`: `threadState.topic`
+     *   `scheduledDate`: `threadState.selectedDate`
+     *   `threadId`: `message.channelId`
+     *   (`bookingTimestamp` will use the default)
+ 4.  Attempt to `save()` the document to MongoDB.
+ 5.  Handle the save result:
+     *   **Success:**
+         *   Send confirmation message to thread: `message.channel.send(`Great! You're confirmed to speak on '${threadState.topic}' on ${formatDate(threadState.selectedDate)}.`)` (reuse/create a `formatDate` helper).
+         *   Remove the thread from the active sign-up map (or mark state as `'confirmed'`).
+     *   **Failure (Catch Error):**
+         *   Check if the error is a duplicate key error (MongoDB error code 11000). This indicates a race condition (someone booked the slot *just* now).
+             *   Send message to thread: "Oh no! It looks like someone just booked ${formatDate(threadState.selectedDate)}. Let me find the next available dates..."
+             *   *Action:* Re-run the logic from Prompt 2.3/2.4: fetch fresh booked dates, call `findNextAvailableFridays`, present new options, and set state back to `'awaiting_date_selection'`. (This might be complex, alternatively, just tell them it failed and ask them to restart the process). For simplicity now: Tell them it failed and ask them to restart: "Oh no! It looks like someone just booked ${formatDate(threadState.selectedDate)}. Sorry about that. Could you please try signing up again?" Then remove/close the thread state.
+         *   For other database errors:
+             *   Log the error internally.
+             *   Send message to thread: "Sorry, there was a database error saving your booking. Please try again later."
+             *   Remove/close the thread state.
+ 6.  Update tests:
+     *   Simulate the flow up to `'awaiting_confirmation'`.
+     *   Mock `ScheduledSpeaker.prototype.save`.
+         *   Test success path: Verify `save` is called with correct data, confirmation message sent, state map updated/cleared.
+         *   Test failure path (duplicate key): Mock `save` to throw a MongoDB error with code 11000. Verify the "slot taken" message is sent and state map is updated/cleared.
+         *   Test failure path (other DB error): Mock `save` to throw a generic error. Verify the generic error message is sent and state map is updated/cleared.
+ 
+ Provide the updated `bot.js` and the updated test file.
+ ```
+ 
+ ---
+ 
+ ### Prompt 4.1: Schedule View Intent Recognition (Simple)
+ 
+ ```text
+ Task: Detect user intent to view the schedule.
+ 
+ Building on the previous steps:
+ 
+ 1.  Modify the main `handleMessage` function in `bot.js`.
+ 2.  Add another check *after* the sign-up intent check: If the message mentions the bot, check for keywords like "schedule", "upcoming", "speakers", "who is speaking".
+ 3.  If a keyword is found AND it wasn't already handled as a sign-up intent:
+     *   Log "Schedule view intent detected from [username]" to the console. *Do not proceed further yet.*
+ 4.  Update tests (`test/intent.test.js` or a new file):
+     *   Add tests for various schedule view messages mentioning the bot -> verify console log.
+     *   Ensure sign-up messages don't trigger the schedule view log.
+     *   Ensure messages mentioning the bot with neither intent trigger nothing.
+ 
+ Provide the updated `bot.js` and the updated test file.
+ ```
+ 
+ ---
+ 
+ ### Prompt 4.2: Fetch & Display Schedule
+ 
+ ```text
+ Task: Fetch the upcoming schedule from the database and display it.
+ 
+ Building on the previous steps:
+ 
+ 1.  Modify `bot.js`. When schedule view intent is detected (Prompt 4.1):
+     *   Query the `ScheduledSpeaker` collection:
+         *   Filter: `scheduledDate` greater than or equal to the start of today (ignore time). Construct a date for comparison: `const today = new Date(); today.setHours(0, 0, 0, 0);` Use `{ scheduledDate: { $gte: today } }`.
+         *   Sort: By `scheduledDate` ascending (`{ sort: { scheduledDate: 1 } }`).
+         *   Limit: 5 (`{ limit: 5 }`).
+     *   Handle potential database errors during the query (log error, reply "Sorry, couldn't fetch schedule due to DB error.").
+     *   Format the results:
+         *   If no results: `reply = "There are no upcoming speakers scheduled yet."`
+         *   If results found: Construct the message string as specified:
+             ```
+             Upcoming Speakers:
+             - [Date1]: @[Username1]
+             - [Date2]: @[Username2]
+             ...
+             ```
+             Use a date formatting helper (e.g., "Mon, Oct 30th"). Make sure to use `discordUsername` from the database record.
+     *   Send the formatted `reply` back to the original channel (`message.channel.send(reply)`).
+ 2.  Update tests:
+     *   Mock `ScheduledSpeaker.find`.
+     *   Simulate a schedule view message.
+     *   Test case: DB returns 3 future speakers. Verify `find` called with correct query ({$gte: today}, sort, limit). Verify the formatted message is correct.
+     *   Test case: DB returns 0 speakers. Verify the "no upcoming speakers" message.
+     *   Test case: DB returns 7 speakers. Verify only 5 are included in the message.
+     *   Test case: DB query throws error. Verify the error message is sent.
+ 
+ Provide the updated `bot.js` and the updated test file.
+ ```
+ 
+ ---
+ 
+ ### Prompt 4.3: NLP & Clarification Refinement (Sign-up)
+ 
+ ```text
+ Task: Improve date selection parsing and add a clarification loop for sign-up.
+ 
+ Building on the previous steps:
+ 
+ 1.  Install a simple NLP library if desired (e.g., `npm install compromise`) or stick to enhanced regex/keyword logic.
+ 2.  Modify the logic in `bot.js` that handles messages in the `'awaiting_date_selection'` state (from Prompt 3.1).
+ 3.  **Enhanced Parsing:**
+     *   Instead of just 1st/2nd/3rd/exact match, try to be more flexible.
+         *   Use `compromise` basics (`nlp(text).dates().get(0)`) to extract potential dates, or use regex for patterns like "the 15th", "Oct 27".
+         *   Compare any extracted/parsed date against the `threadState.proposedDates`. **Crucially, compare only the date part (YYYY-MM-DD).**
+         *   Also, retain the simple 1st/2nd/3rd checks as fallbacks.
+ 4.  **Clarification Loop:**
+     *   If the parsing attempt fails to confidently identify *one* of the `proposedDates`:
+         *   Increment a counter in the state map: `threadState.clarificationAttempts = (threadState.clarificationAttempts || 0) + 1;`
+         *   Check if `clarificationAttempts` exceeds a limit (e.g., 2).
+             *   If limit exceeded: Send message "Sorry, I'm still having trouble understanding. Could you please restart the sign-up process, or ask an admin for help?". Close/remove the thread state.
+             *   If limit not exceeded: Send clarification message: "Sorry, I didn't quite catch that. Which of these dates works best?
+ 1. [Formatted Date 1]
+ 2. [Formatted Date 2]
+ 3. [Formatted Date 3]" (Re-present the original options). **Do not change the state.** Stay in `'awaiting_date_selection'`.
+     *   If parsing *succeeds*: Proceed to the confirmation/saving logic (`'awaiting_confirmation'` state change) as before (Prompt 3.2). Reset `clarificationAttempts` if it exists.
+ 5.  Update tests:
+     *   Add tests for the enhanced parsing logic (unit test the parser function separately if complex). Test inputs like "how about the first one", "the 27th works", "I'll take Friday the 13th" (assuming these correspond to proposed dates).
+     *   Update integration tests for the `'awaiting_date_selection'` state:
+         *   Simulate ambiguous input ("maybe the second one?"). Verify clarification message is sent, state remains `awaiting_date_selection`, attempt counter incremented.
+         *   Simulate another ambiguous input. Verify clarification message sent again, counter incremented.
+         *   Simulate a third ambiguous input. Verify "ask admin" message sent, thread state closed/removed.
+         *   Simulate ambiguous input, followed by a clear input ("ok, the first one"). Verify it eventually proceeds to confirmation.
+ 
+ Provide the updated `bot.js` (potentially with a new `lib/nlpParser.js` if needed) and the updated test file.
+ ```
+ 
+ ---
+ 
+ ### Prompt 4.4: Error Handling Implementation
+ 
+ ```text
+ Task: Implement remaining specified error handling.
+ 
+ Building on the previous steps:
+ 
+ 1.  Review all existing error handling points in `bot.js` and `lib/db.js` against the spec.
+ 2.  **Database Errors:** Ensure all `.catch()` blocks for Mongoose operations (`.save()`, `.find()`) log the specific error internally (e.g., `console.error('DB Error:', error);`) and send a user-facing generic message ("Sorry, I encountered a database issue...") to the appropriate channel/thread, unless a more specific message is already handled (like the race condition). Ensure the bot state is cleaned up appropriately (e.g., close thread state).
+ 3.  **Race Condition (Refined):** Revisit the duplicate key error (11000) handling during save (Prompt 3.2). Confirm the chosen behavior (inform user slot taken, ask to restart) aligns with the final plan. If re-prompting is desired, implement that logic now (fetch new dates, send options, reset state). *Current prompt assumes the simpler "ask to restart"*.
+ 4.  **No Available Dates:** Ensure the logic in Prompt 2.4 correctly handles the case where `findNextAvailableFridays` returns an empty array and sends the specified message ("...no upcoming Friday slots available...").
+ 5.  **NLP Ambiguity:** Ensure the final "Sorry, I'm still having trouble..." message from the clarification loop (Prompt 4.3) is implemented.
+ 6.  **Discord API Errors:** Wrap key `discord.js` calls that interact with the API (e.g., `message.startThread()`, `channel.send()`, `thread.send()`) in `try...catch` blocks. Log any caught errors. Decide if a generic user-facing message is needed (e.g., "Sorry, I couldn't perform that Discord action.") or if just logging is sufficient. Often, these might be permission errors admins need to fix. Just log for now unless specified otherwise.
+ 7.  **Test Error Handling:**
+     *   Review existing tests for error conditions (DB errors, race condition, NLP ambiguity).
+     *   Add specific tests if missing:
+         *   Mock `message.startThread` to throw an error -> verify error is logged.
+         *   Mock `channel.send` to throw an error -> verify error is logged.
+         *   Mock `ScheduledSpeaker.find` (in schedule view) to throw -> verify DB error message sent to channel.
+         *   Ensure the "no available dates" scenario test is robust.
+ 
+ Provide the final updated `bot.js` incorporating these checks and error handlers, and any necessary updates to test files. This should represent the functionally complete bot based on the spec.
+ ```
+ 
```

---

Alright, Big D, the file `docs/plans/01-initial.md` now contains the detailed build plan and the sequence of TDD prompts for the code-generation LLM. Each prompt builds on the last, focusing on small, testable increments as requested. Let me know when you're ready for the next step!

---

_**User**_

use tree to look at the current codebase and remove anything that has already been done from the @plans 

---

_**Assistant**_



---

Okay, Big D. First, I'll check the current state of your codebase using `tree`.

---

```bash
tree -I node_modules
```

```
.
├── README.md
├── api
│   ├── auth-test.js
│   └── widgets.js
├── config
│   └── index.js
├── docs
│   ├── plans
│   │   └── 01-initial.md
│   ├── specs
│   │   └── 01-initial.md
│   └── tutorials
├── index.js
├── lib
│   ├── auto-catch.js
│   ├── discord
│   │   ├── commands
│   │   │   ├── check.js
│   │   │   └── llm.js
│   │   ├── deploy-commands.js
│   │   └── index.js
│   ├── llm
│   │   └── index.js
│   └── mongo
│       ├── index.js
│       ├── mock-mongo.js
│       └── mongo.js
├── middleware
│   ├── auth-test.js
│   ├── auth.js
│   └── index.js
├── models
│   └── widget.js
├── package-lock.json
├── package.json
├── server.js
└── test
    ├── api
    │   ├── health.test.js
    │   └── widgets.test.js
    ├── auth.test.js
    ├── auto-catch.test.js
    ├── helpers
    │   ├── cleanup.js
    │   └── mock-auth.js
    ├── index.js
    └── mongo.test.js

16 directories, 31 files


~/play/test/ai-in-action-bot main*

```

---

Okay, Big D. Looking at the `tree` output, it seems like none of the specific files outlined in the plan (like `bot.js`, `lib/db.js`, `lib/scheduleLogic.js`, `models/scheduledSpeaker.js`, or the corresponding test files) exist yet. The project has some existing structure, but not the components specific to the speaker scheduling bot plan.

Therefore, no steps need to be removed from `docs/plans/01-initial.md` at this time. The plan remains as is, starting from Step 1.1.

---



---

